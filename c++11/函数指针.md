# 函数指针

函数值针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型，**函数的类型由他的返回值和形参类型共同决定，与函数名无关**

例如：

```c++
bool lengthCompare(const string &, const string &);
//该函数类型是 bool(const string &, const string &).---想要声明一个可以指向该函数的指针， 只需要用指针替换函数名即可。
bool (*pr)(const string&, ocnst string&); //未初始化
//****  *pr 两端的括号必不可少，如果不写括号，则 pr 是一个返回值为bool指针 的函数 
// bool *pr(const string&, const string&);  //返回值为 bool*
```



## 使用函数指针

```c++
#include <iostream>

bool length_compare(const std::string &A, const std::string &B)
{
    return A.length() > B.length() ? true : false;
}

std::string::size_type sum_length(const std::string &A, const std::string &B){
    return A.length() + B.length();
}

int main()
{
    bool (*pr)(const std::string &A, const std::string &B);
    bool (*pr2)(const std::string &A, const std::string &B);
    bool (*pf)(const std::string &A, const std::string &B);
    typedef  bool (*FuncP)(const std::string &A, const std::string &B);

    FuncP my_func = length_compare;
    
    pr = length_compare;
    pr2 = &length_compare;

    bool b1 = pr("hello", "goodbye");
    bool b2 = (*pr2)("hello", "goodbye");
    bool b3 = length_compare("hello", "goodbye");
    bool b4 = my_func("hello","goodbye");

    std::cout << "b1 = " << b1 << std::endl;
    std::cout << "b2 = " << b2 << std::endl;
    std::cout << "b3 = " << b3 << std::endl;
    std::cout << "b4 = " << b4 << std::endl;
    
    pf = 0;
    // pf = sum_length;

    return 0;
}

```



可以为函数指针赋一个nullptr 或 0 的整数常量表达式， 表示该指针没有指向任何函数。

```c++
 bool (*pf)(const std::string &A, const std::string &B);
string::std::string::size_type sum_length(const std::string &A, const std::string &B);
bool cstring_compare(const char*, const char*);
pf = 0;
pf = sum_length; //错误：返回值类型不匹配
pf = cstring_compare; // 形参类型不匹配
pf = length_compare; //正确
```

## 重载函数指针

使用重载函数，必须清晰的界定到底该选用那个函数。

```c++
void ff(int*);
void ff(unsigned int);

void (*pf1)(unsigned int) = ff; //pf1 指向 ff(unsigned)

//编译器通过指针类型决定选用那个函数，指针类型必须与重载函数中的某个精确匹配
void (*pf2)(int) = ff;	// 错误： 没有任何一个ff与该形参列表匹配
double (*pf3)(int*) = ff; //错误：ff 和 pf3 的返回类型不匹配
```



## 函数指针形参



```c++
// 形参看起来是函数类型，实际上是当作指针使用
// 第三个参数是函数类型，他会自动的指向函数指针
void useBigger(const string &s1, const string &s2, bool pf(const string &, const string &));
//等价声明
void useBigger(const string &s1, const string &s2, bool (*pf)(const string &, const string &));
//我们可以直接把函数作为实参使用，此时他会自动转化为指针：
useBigger(s1, s2, length_compare);

```

**使用函数指针类型冗余而繁琐**

类型别名和decltype能简化我们使用函数指针的代码

typedef **为函数指针创建别名**

```
typedef bool (*CompareFunc)(int, int);
```

在这个示例中，`CompareFunc` 被定义为指向函数的指针类型，该函数接受两个 `int` 参数并返回 `bool` 类型的结果。可以使用 `CompareFunc` 来声明函数指针变量。

```c++
//Func 和 Func2 是函数类型
typedef bool Func(const string&, const string&);
typedef decltype(length_compare) Func2; // 等价类型

// FuncP 和 FuncP2 是指向函数的指针
//decltype 返回函数类型，此时不会将函数类型自动转换成指针类型，---所以只有在结果前面加上 * 才能得到指针。
typedef bool (*FuncP)(const string&, const string&);
typedef decltype(lenth_compare) *FuncP2; //等价类型

//useBigger 等价声明， 其中使用了类型别名
//第一条语句，编译器自动的将func 表示的函数类型 转换为指针
void useBigger(const string&, const string&, Func);
void useBigger(const string&, const string&, FuncP2);
```

typedef **为函数创建别名**

```c++
#include <iostream>

// 原始的函数指针声明
typedef void (*CallbackFunc)(int);

// 别名定义
typedef CallbackFunc MyCallback;

// 示例函数
void PrintNumber(int num) {
    std::cout << "Number: " << num << std::endl;
}

int main() {
    // 使用别名声明函数指针变量
    MyCallback myCallback = PrintNumber;

    // 使用函数指针调用函数
    myCallback(42);

    return 0;
}

```



## 返回指向函数的指针



## 函数指针和指针函数的区别：

- 函数指针是指向函数的指针；
- 指针函数是返回类型为指针的函数；



# 